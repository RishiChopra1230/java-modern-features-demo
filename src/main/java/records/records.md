
# Inspiration
- Object to represent data  ( with minimal behaviour ) 
- Languages Like Scala and Kotlin have data classes

# Introduction
- Introduced in Java 14 
- Records which are plain data classes
- Records represent immutable data (Include methods but they are mainly there to handle data with ease)
- Records remove boilerplate code and provide some built-in methods to easily work with data
- Records implicitly extend from java.lang.Record.
- Records are special types of classes but are classes nevertheless.
- Records aren’t allowed to extend from any classes or other records.
- Records can’t serve as a base class.
- Records may also be used to represent tuples for easy creation of a finite sequence of data. ( local records)
- Records are implicitly marked final and thus can’t be extended—they’re intended to be carriers of data, not a
  representation of any significant business rule, logic, or behavior.
- The JDK has provided a function isRecord() in the metaclass Class to distinguish between classes and record
- Since records are carriers of data, the JDK provides an easy way to access the data within records, using a getRecordComponents() method of the metaclass Class.
  The method returns a collection of java.lang.reflect.RecordComponent, which provides many details of the components.
- Records act like lightweight classes, can implement interfaces but don't overdo unless there is a reason.
- Records cannot explicitly extends from java.lang.Record as well.
- Records make it easier to work with data and make the code more concise and less error-prone.

# Constructor
- No explicit constructors required.
- The canonical constructor is automatically generated so that each of the fields corresponding to the components is initialized in the same order as they
  appear in the parameter list you provide in the record declaration.
- Canonical constructor can be overridden.

# Compact Constructor
- Compact constructor more like a preprocessor than a constructor
- It’s invoked before the autogenerated canonical constructor is called.
- The compact constructor doesn’t have a parameter list.
- The parameters provided on the declaration line of the record are available within the compact constructor
- Since the actual constructor hasn’t been invoked yet, we can’t access this anywhere in the compact constructor.
- Use the compact constructor to validate,transform, and/or cleanse data, and leave the initialization of the fields to
  the autogenerated canonical constructor
- Once we return from the compact constructor, the autogenerated constructor will kick in to initialize the fields with the transformed values 
  from the compact constructor.
- It may help to think of the compact constructor as a filter or a map operation between the code that creates an instance and the autogenerated constructor
  that completes the initialization.
- The compact constructor also removes some redundancies that exist in a canonical constructor ( duplicate initialization )

# Custom Noncanonical Constructor
-A noncanonical constructor looks like any constructor we’d generally write, but it has to call the canonical constructor or another noncanonical constructor as the first statement.

# Fields
- Not allowed to define instance fields explicitly inside the body of a record.
- The fields of a record are derived from the components listed in the definition of the record—the list in the parentheses
- Fields are immutable in the record definition by default - you don't need to mark it.
- May define ‘static‘ fields within a record.
- Since the components are immutable, their corresponding fields are final.
- The fields that are behind components of a record are all declared final and the references can’t be mutated.
- A record’s components’ references are all initialized at the time of the instance initialization and can’t be modified after that.

# Methods 
- There are no setters for the components/fields.
- Methods do not follow Java bean convention but define as 'fieldName()'
- When we print an instance of a record, the output shows the values for the fields due to automatic implementation of a toString.
- A toString() method is provided for the record and it returns a String representa-
  tion of each component in the form of its name and its value.
- The equals() method that’s provided automatically will return true if two
  instances of record are of the same type and if each of the components of the
  records has equal values.
- The hashCode() method, as you know, goes hand-in-hand with the equals() method.
  If one is overridden in a class, the other is required to be implemented correctly
  as well. Such concerns are removed by the default implementation of the
  hashCode() method along with the equals() method in records.
- For each of the components, a getter method is automatically created. The
  return type of the method is the same as that of the corresponding component.
  The name of the method is the same as the name of the component.

# Caution
- Where possible, make sure the components’ types are themselves immutable, like String or other records for instance.
- When creating an instance of a record, if a component’s type is an interface or an abstract base class, choose an implementation that’s immutable. 
  For example, if a component’s type is List<String>, choose an immutable instance returned by List.of() or List.copyOf() instead of an instance of ArrayList<String>.
- When using a record don’t mutate any of its members. Design your code fully knowing that records aren’t intended to be altered.